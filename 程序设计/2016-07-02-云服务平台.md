<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline1">1. 服务发现和注册:Discovery Service</a></li>
<li><a href="#orgheadline6">2. 分布式配置管理</a>
<ul>
<li><a href="#orgheadline2">2.1. 分布式配置管理平台Disconf: 此文有很多方案对比，非常好。</a></li>
<li><a href="#orgheadline3">2.2. 奇虎360-QConf-基于zookeeper实现</a></li>
<li><a href="#orgheadline4">2.3. 淘宝分布式配置管理服务Diamond</a></li>
<li><a href="#orgheadline5">2.4. spring_clound</a></li>
</ul>
</li>
<li><a href="#orgheadline7">3. 集群群首选举和锁定</a></li>
<li><a href="#orgheadline10">4. springClound专题</a>
<ul>
<li><a href="#orgheadline8">4.1. 特性:</a></li>
<li><a href="#orgheadline9">4.2. Spring Cloud 1.0正式版所实现的主要改进内容包括 -&gt;</a></li>
</ul>
</li>
<li><a href="#orgheadline12">5. 微服务架构入门</a>
<ul>
<li><a href="#orgheadline11">5.1. 微服务架构的优势与不足</a></li>
</ul>
</li>
<li><a href="#orgheadline15">6. 各种链接</a>
<ul>
<li><a href="#orgheadline13">6.1. spring clound</a></li>
<li><a href="#orgheadline14">6.2. 微服务实战</a></li>
</ul>
</li>
</ul>
</div>
</div>

一个云服务平台需要的基本功能

# 服务发现和注册:Discovery Service<a id="orgheadline1"></a>

每个服务都有一个名字，这个名字会被注册到平台服务器，所有连接上平台服务器的客户端都可以通过这个名字来调用该服务。

已知有3个比较主流的产品

-   zookeeper:基于java，源自于hadoop，比较成熟。
-   nginx/consul:Consul 是一套开源的分布式服务发现和配置管理系统，由 HashiCorp 公司用 Go 语言开发。[Consul 简介](http://blog.csdn.net/yeasy/article/details/47277031)
-   Netflix/eureka: 隶属于spring\_clound解决方案，Eureka服务器和Eureka客户端。Eureka服务器用作服务注册服务器。Eureka客户端是一个java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。Netflix在其生产环境中使用的是另外的客户端，它提供基于流量、资源利用率以及出错状态的加权负载均衡。

Spring cloud的服务注册及发现，不仅仅只有eureka，还支持Zookeeper和Consul。

# 分布式配置管理<a id="orgheadline6"></a>

分布式环境中，出于负载、容错等种种原因，几乎所有的服务都需要在不同的机器节点上部署多个实例。当然，业务项目中总少不了各种类型的配置文件，我们常常会遇到这样的问题，有时仅仅是一个配置内容的修改，便需要重新进行代码提交svn/git，打包，分发上线的流程。当部署的机器有很多时，分发上线本身也是一个很繁杂的工作。而配置文件的修改频率又远远大于代码本身。

## [分布式配置管理平台Disconf](https://github.com/knightliao/disconf/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0Disconf): 此文有很多方案对比，非常好。<a id="orgheadline2"></a>

分布式配置管理应该是分布式系统和微服务应用的第一步。想象一下如果你有几十个服务或应用需要配置，而且每个服务还分为开发、测试、生产等不同维度的配置，那工作量是相当大的，而且还容易出错。如果能把各个应用的配置信息集中管理起来，使用一套机制或系统来管理，那么将极大的提高系统开发的生产效率，同时也会提高系统开发环境和生产环境运行的一致性。

各种方案比较:

-   王阿晶提出了基于zooKeeper的配置信息存储方案的设计与实现, 它将所有配置存储在zookeeper上，这会导致配置的管理不那么方便，而且他们没有相关的源码实现。
-   淘宝的diamond 是淘宝内部使用的一个管理持久配置的系统，它具有完整的开源源码实现，它的特点是简单、可靠、易用，淘宝内部绝大多数系统的配置都采用diamond来进行统一管理。他将所有配置文件里的配置打散化进行存储，只支持KV结构，并且配置更新的推送是非实时的。
-   百度内部的BJF配置中心服务采用了类似淘宝diamond的实现，也是配置打散化、只支持KV和非实时推送。


<table border="0" cellspacing="0" cellpadding="0">
  <tr>
   <th width="100px"></th>
   <th width="100px">淘宝Diamond[2]</th>
   <th width="150px">Disconf</th>
   <th width="150px">比较</th>
  </tr>
  <tr>
    <td width="100px"><b>数据持久性<b/></td>
    <td width="150px">存储在mysql上</td>
    <td width="150px">存储在mysql上</td>
  <td width="150px">都持久化到数据库里，都易于管理</td>
  </tr>
  <tr>
    <td width="100px"><b>推拉模型<b/></td>
    <td width="150px">拉模型，每隔15s拉一次全量数据</td>
  <td width="150px">基于Zookeeper的推模型，实时推送</td>
    <td width="150px">disconf基于分布式的Zookeeper来实时推送，不断是在稳定性、实效性、易用性上均优于diamond</td>
   </tr>
   <tr>
    <td width="100px"><b>配置读写<b/></td>
    <td width="150px">支持实例对配置读写。支持某台实例写配置数据，并广播到其它实例上</td>
  <td width="150px">只支持实例对配置读。通过在disconf-web上更新配置到达到广播写到所有应用实例</td>
    <td width="150px">从目前的应用场景来看，实例对配置的写需求不是那么明显。disconf支持的中心化广播方案可能会与人性思考更加相似。</td>
  </tr>
  <tr>
    <td width="100px"><b>容灾<b/></td>
    <td width="150px">多级容灾模式，配置数据会dump在本地，避免中心服务挂机时无法使用</td>
  <td width="150px">多级容灾模式，优先读取本地配置文件。</td>
    <td width="150px">双方均支持在中心服务挂机时配置实例仍然可以使用</td>
  </tr>
  <tr>
    <td width="100px"><b>配置数据模型<b/></td>
    <td width="150px">只支持KV结构的数据，非配置文件模式</td>
  <td width="150px">支持传统的配置文件模式（配置文件），亦支持KV结构数据(配置项)</td>
    <td width="150px">使用配置文件的编程方式可能与程序员的编程习惯更为相似，更易于接受和使用。</td>
  </tr>  
  <tr>
    <td width="100px"><b>编程模型<b/></td>
    <td width="150px">需要将配置文件拆成多个配置项，没有明显的编程模型</td>
  <td width="150px">在使用配置文件的基础上，提供了注解式和基于XML的两种编程模型</td>
    <td width="150px">无</td>
  </tr>  
  <tr>
    <td width="100px"><b>并发性<b/></td>
    <td width="150px">多条配置要同时生效时，无法解决并发同时生效的问题</td>
  <td width="150px">基于注解式的配置，可以解决并发性问题</td>
    <td width="150px">无</td>
  </tr>  
</table>

## [奇虎360-QConf-基于zookeeper实现](http://www.jianshu.com/p/84746475161b)<a id="orgheadline3"></a>

可以将单条配置内容直接存储在ZooKeeper的一个ZNode上，并利用ZooKeeper的Watch监听功能实现配置变化时对客户端的及时通知。

目前360内部已经广泛的使用QConf。覆盖云盘、大流程、系统部、dba、图搜、影视、地图、硬件、手机卫士、好搜等大部分业务。
部署国内外共51几个机房，客户端机器超两万台，稳定运行两年。

其中diamond和vintage比较类似，他们将配置数据存在像mysql或redis这样的存储中，并需要通过客户端的轮训来感知配置变化，这样会有很多的无效通讯，因此采取比较md5值的方式来避免整个配置值的传输；

disconf与QConf类似，同样采用ZooKeeper的通知机制，不同的是，其将真实的配置数据存在mysql中，并且整个与java耦合很重，且配置复杂。

## [淘宝分布式配置管理服务Diamond](http://ju.outofmemory.cn/entry/95031)<a id="orgheadline4"></a>

Diamond则是淘宝开源的一种分布式配置管理服务的实现。Diamond本质上是一个Java写的Web应用，其对外提供接口都是基于HTTP协议的，在阅读代码时可以从实现各个接口的controller入手。

配置管理服务往往会封装一个客户端库，应用方则是基于该库与配置管理服务进行交互。在实际实现时，客户端库可能是主动拉取(pull)数据，但对于应用方而言，一般是一种事件通知方式。

Diamond中的数据是简单的key-value结构。应用方订阅数据则是基于key来订阅，未订阅的数据当然不会被推送。数据从类型上又划分为聚合和非聚合。因为数据推送者可能很多，在整个分布式环境中，可能有多个推送者在推送相同key的数据，这些数据如果是聚合的，那么所有这些推送者推送的数据会被合并在一起；反之如果是非聚合的，则会出现覆盖。

## [spring\_clound](http://www.cnblogs.com/skyblog/p/5129603.html)<a id="orgheadline5"></a>

在传统开发中我们往往需要自己开发“配置管理服务器”，你可以使用redis、ldap、zookeeper、db等来存放统一配置信息，然后开发一个管理界面来进行管理。传统的做法没什么问题，和spring cloud所提供的配置管理方案相比，就是前者需要自己开发，而后者直接简单使用现成的组件即可。当然还有很重要的一点，spring 配置管理模块由于是spring boot核心来实现的，因此做了大量的工作，可以把一些启动参数进行外部配置，这在传统的方案中是很难办到的，因为涉及到要改写第三方组件的问题，难度很大。比如web应用的绑定端口，传统应用只能在tomcat配置文件里改，而spring cloud却可以放到远程，类似的还有数据库连接、安全框架配置等。

# 集群群首选举和锁定<a id="orgheadline7"></a>

# springClound专题<a id="orgheadline10"></a>

Pivotal最近发布了Spring Cloud 1.0开放源码库，[为基于JVM的云应用开发提供了一种简单的开发方式](http://www.infoq.com/cn/news/2015/03/develop-tool-spring-cloud) 。他可使应用程序连接到不同的云服务并且在运行时获取云环境的信息。无论是否基于Spring，应用程序都可以使用Spring Cloud。Spring Cloud 1.0目前支持Cloud Foundry和Heroku两种云平台，也可以通过扩展来支持更多的云平台。

-   云平台连接器（Cloud Connector）
-   服务连接器（Service Connector

## 特性:<a id="orgheadline8"></a>

它为基于JVM的云应用开发中的

-   配置管理、
-   服务发现、
-   断路器、
-   智能路由、
-   微代理、
-   控制总线、
-   全局锁、
-   决策竞选、
-   分布式会话和集群状态管理

等操作提供了一种简单的开发方式

## Spring Cloud 1.0正式版所实现的主要改进内容包括 -><a id="orgheadline9"></a>

-   Spring Cloud Config子项目支持使用Git配置客服务器
-   Spring Cloud Config子项目支持客户端的配置信息刷新、加密/解密配置、基于Spring应用的声明周期阶段配置
-   Spring Cloud Commons子项目实现了负载均衡、服务发现和断路器（Circuit Breaker）
-   Spring Cloud Security子项目实现了声明式的SSO和基于代理的认证策略
-   Eureka子项目实现了非JVM客户端的支持
-   使用Zuul实现了自动反向代理
-   Spring配置模型已支持Zuul过滤器和云中间层服务库Ribbon负载均衡配置
-   通过Ribbon集成实现了伪声明式的Web服务客户端
-   实现了RestTemplate同Ribbon的集成
-   分布式系统的延迟和容错库Hystrix通过客户端操作界面即可实现断路器
-   实时流、低延时、高吞吐量的聚合器Turbine实现了环路聚合、基于HTTP的Pull操作和基于AMQP的Push操作
-   对AWS服务的集成实现了对相关数据库、消息、EC2元数据的支持
-   为AMQP总线定义了一套操作事件，如配置变化等
-   Groovy CLI实现了对上述多数功能的支持

# 微服务架构入门<a id="orgheadline12"></a>

## 微服务架构的优势与不足<a id="orgheadline11"></a>

fwef

# 各种链接<a id="orgheadline15"></a>

## spring clound<a id="orgheadline13"></a>

-   [spring cloud独立功能介绍和demo 分布式配置服务器、客户端、服务发现、负载均衡、断路器Hytrix](https://github.com/xuminwlt/j360-cloud-all)
-   [7天学会spring cloud系列》](http://www.cnblogs.com/skyblog/p/5129603.html)
-   [Spring Cloud Brixton.RELEASE正式发布](http://www.infoq.com/cn/news/2016/06/Spring-Cloud-Brixton)
-   [Spring Cloud 1.0 – 云平台抽象化](http://www.infoq.com/cn/news/2014/06/spring-cloud-platform-abstract)

## 微服务实战<a id="orgheadline14"></a>

-   [Microservice](http://microservices.io/)
-   [微服务实战（一）：微服务架构的优势与不足](http://dockone.io/article/394)
