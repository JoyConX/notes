#+SETUPFILE: ../css/level-1.orgcss
#+TITLE: Protobuffer学习

* cmd

生成python代码: protoc -I=./src --python_out=./dist src/demo.proto

protoc -I=./src --python_out=./dist src/demo.proto

protoc --lua_out=./ person.proto

* 分析

#+begin_src sh
<<26,22,10,17,32,228,24,24,251,6,16,163,6,40,159,239,230,145,252,5,8,9,16,228,24,8,0,34,20,10,16,32,0,24,0,16,146,34,40,219,224,214,13,8,169,233,30,16,0>>


battle_pb:decode_battle_result(<<26,22,10,18,32,228,24,24,251,6,16,163,6,40,159,239,230,145,252,5,8,9,16,228,24,8,0,34,20,10,16,32,0,24,0,16,146,34,40,219,224,214,13,8,169,233,30,16,0>>).


battle_pb:decode_hero_result(<<32,228,24,24,251,6,16,163,6,40,159,239,230,145,252,5,8,9>>).
battle_pb:decode_team_result(<<10,18,32,228,24,24,251,6,16,163,6,40,159,239,230,145,252,5,8,9,16,3>>).



message Test1 {
required int32 a = 1;  -> 150
}

08 0000 1000
96 1001 0110
01 0000 00001

<<B8:1, B7:1, B6:1, B5:1, B4:1,B3:1,B2:1,B1:1>> = 255.

26  00011 010  field 3 type Length-delimited  team_result
22  00010110  length 22

10 0000 1 010 filed 1 type  Length-delimited  hero_result
17 10001 length 17

------------>
32 100 000  filed 4 type Varint
228 1110 0100
24  00001 1000    -> 110001100100 -> 3172
24 000011 000  -> field 3 type Varint
251 1111 1011
6  000 00110  -> 001101111011 -> 891
16 10 000  -> field 2 type varint
163 1010 0011
6  0000 0110  -> 1100100011 -> 803
40 101 000  -> filed 5 type varient  6 byte
159 1001 1111
239 1110 1111
230 1110 0110
145 1001 0001
252 1111 1100
5   00000 101  10111111000010001110011011011110011111  -> 205122025375
8   1 000  -> filed 1 type variet
--->
9  ->  数字9 9  ->

16  10 000  -> filed 2 -> type varited
228  11100100

--------------->
24 00011 000
8
0
34
20
10
16
32
0
24
0
16
146
34
40
219
224
214
13
8
169
233
30
16
0

2#1111111111111111111111111111111111111111. -> 1099511627775
#+end_src


* Protobuf-net在Unity中的序列化与反序列化

原文链接 http://coder.beitown.com/archives/1192

本篇中我们只讲解如何在Unity中对Protobuf-net进行序列化(Serialize)与反序列化(Deserialize),关于Unity的socket网络通信部分我们后续开篇。

首先去Protobuf-net的Google下载点下载protobuf-net类库：https://code.google.com/p/protobuf-net/downloads/list
这里用的是目前最新的protobuf-net r668
下载完毕后打开压缩包，在Full\unity中找到protobuf-net.dll将其添加到项目中。
接下来过程其实类似于我之前的一文章《Protobuf在Java中的简单实例》。

①创建proto文件，定义协议格式
首先我们需要创建一个.proto文件来进行测试：

#+begin_src csharp
package com.beitown.net.msg;//包名
message TestMsg {
    required int64 Id=1; 
    required string Name=2;
}
#+end_src


每个字段后标记的“=1”、“=2”这里就不解释了，之前的一篇Protobuf文章中已经做过概述。

②编译Proto文件生成.cs文件
这里我们需要用到一个编译工具ProtoGen，在之前下载的protobuf-net r668.zip中就有。
为了方便管理.proto和.cs文件以及编译快捷，我们可以写一个bat脚本来实现自动编译.proto文件，脚本如下：

#+begin_src bat
@echo off
for /f "delims=" %%i in ('dir /b proto "proto/*.proto"') do protogen -i:proto/%%i -o:cs/%%~ni.cs
pause
#+end_src

为了配合这个脚本，需要在ProtoGen文件夹中另外再创建两个子文件夹，一个proto文件夹，一个cs文件夹。批处理会自动寻找proto文件夹下的.proto文件并编译成相应.cs文件保存到cs目录中。
ok,接下来将之前写好的Test.proto文件放到proto文件夹中，执行creat.bat脚本。此时会在cs文件夹下生成一个名为Test.cs的文件。
我们先来观察一下这个Test.cs文件

#+begin_src csharp
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from: proto/Test.proto
namespace com.beitown.net.msg
{
  [global::System.Serializable, global::ProtoBuf.ProtoContract(Name=@"TestMsg")]
  public partial class TestMsg : global::ProtoBuf.IExtensible
  {
    public TestMsg() {}
    
    private long _Id;
    [global::ProtoBuf.ProtoMember(1, IsRequired = true, Name=@"Id", DataFormat = global::ProtoBuf.DataFormat.TwosComplement)]
    public long Id
    {
      get { return _Id; }
      set { _Id = value; }
    }
    private string _Name;
    [global::ProtoBuf.ProtoMember(2, IsRequired = true, Name=@"Name", DataFormat = global::ProtoBuf.DataFormat.Default)]
    public string Name
    {
      get { return _Name; }
      set { _Name = value; }
    }
    private global::ProtoBuf.IExtension extensionObject;
    global::ProtoBuf.IExtension global::ProtoBuf.IExtensible.GetExtensionObject(bool createIfMissing)
      { return global::ProtoBuf.Extensible.GetExtensionObject(ref extensionObject, createIfMissing); }
  }
  
}
#+end_src



和Protobuf-Csharp的编译机制编译出的cs文件比起来要清晰简单很多,同理和java端的编译后文件比起来也非常清晰，这也是Protobuf-net的一个让人觉得亲切的地方，尽管自动生成的代码我们都不会再去手动修改甚至去浏览。
接下来将这个Test.cs文件添加到项目中，即可对TestMsg这个protobuf结构进行操作了。

③序列化与反序列化
在发送数据前我们需要将Protobuf结构进行序列化，在本例中即给之前定义的TestMsg结构体赋值，并将其转换成二进制形式方便通信机制发送。
这里直接写成了静态方法。

i 序列化：

#+begin_src csharp
using ProtoBuf;
public static byte[] Serialize(IExtensible msg)
        {
            byte[] result;
            using (var stream = new MemoryStream())
            {
                Serializer.Serialize(stream, msg);
                result = stream.ToArray();
            }
            return result;
        }
#+end_src


IExtensible是ProtoBuf包下的一个公共接口，参考Test.cs的文件结构（TestMsg : global::ProtoBuf.IExtensible）可以发现，在整个规则中所有的的protobuf结构都实现了ProtoBuf.IExtensible这个接口，因此也方面我们的封装。

接下来是反序列化的封装。
ii 反序列化：

#+begin_src csharp
using ProtoBuf;
public static IExtensible Deserialize<IExtensible>(byte[] message)
        {
            IExtensible result;
            using (var stream = new MemoryStream(message))
            {
                result = Serializer.Deserialize<IExtensible>(stream);
            }
            return result;
        }
#+end_src


封装完毕之后我们来看看使用的方法，直接上代码：

#+begin_src csharp
public class Main : MonoBehaviour
{
    // Use this for initialization
    void Start()
    {
        //建立socket连接之类种种忽略...

        Testmsg protoOut= new Testmsg ();
        protoOut.Id = 10046;
        protoOut.name= "beitown";
        byte[] bytes = Serialize(protoOut);

        //socket.send(bytes)之类种种，发送到字节流中...
    }

    // Update is called once per frame
    void Update()
    {
        //当获取到一个消息在bytes中
        TestMsg protoIn = (TestMsg)Deserialize<TestMsg>(bytes);//强转成TestMsg类型
        Debug.log("Id: " + protoIn.Id);//获取Id
        Debug.log("Name: " + protoIn.Name);//获取Name

    }
}
#+end_src

以上代码写的略做精简，不涉及任何通信部分的描述，大家需要根据自己的情况来进行另外的封装，这里就不再描述了，后续可能会写一篇UnitySocket封装和智能Command的文章，到时再做叙述。
参照本文中的内容再加上一个简单的Socket通信，即可完成一个简单的Unity Protobuf-net的小Demo，感兴趣的朋友可以继续，望能抛砖引玉。
本篇到此，谢谢关注。


接下来要在Unity中应用  还应该把protobuf-net的源码放入Plugins
接着在Asset目录下创建smcs.rsp 
内容为：
-unsafe
然后把你生成的.cs文件放入  就OK了

unsafe code.
