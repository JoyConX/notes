http://riak.com.cn/riak/1.4.2/theory/why-riak/

* 为什么使用 Riak

** Riak 是什么？

Riak 是一种分布式数据库，其设计目的是保持最大限度的可用性，只要客户端可以访问服务器，就能写入数据。如果失败了，大多数情况下数据还是可读的，只不过读出的数据可能过时了。
高度可用性的代价是可能过期的数据，这种妥协是 Riak 的关键架构方案。这种方案称为“最终一致性”，在分布式系统中很常见，比较著名的例子有 DNS 和 Web 缓存。

** Basho 对 Riak 设定的目标

| 目标	     | 说明                                                                              |
| 可用性     | 	Rial 在多个服务器上进行读写操作，即使出现硬件或网络问题，也能保证数据库的可用性 |
| 操作便利性 | 	在 Riak 集群中添加新设备的过程很简单，无需繁杂地操作                            |
| 可扩放性   | 	Riak 能在集群中自动分发数据，并能随着数据量的增加提升近线性的性能               |
| Masterless | 	对数据库的访问不会绑定到集群中特定的服务器上，避免单个服务器宕机造成无法访问    | 

** 适合使用 Riak 的场景  

如果把数据放在单台服务器中无法满足要求，请考虑使用 Riak 吧。分布式数据库是一个老大难问题，不是任何人都能处理地这么好。
Riak 十分看重可用性，如果你无法接受宕机，Riak 就是个很好地选择。没人能保证 100% 在线，不过在设计 Riak 时就考虑到了如何避免因网络隔断和硬件失效导致无法访问数据库，这两个问题是中断大多数数据库服务的罪魁祸首。
Riak 一个很少提及的特性是可预知的延迟。因为对 Riak 的基本操作（读，写，删除）不涉及复杂地数据连接和锁定，处理起来速度很快。其他数据管理软件就是看中了这一点，经常使用 Riak 储存数据。

** 不太适合使用 Riak 的场景

* [[https://github.com/hectcastro/docker-riak][riak in docker ]]

https://github.com/hectcastro/docker-riak

#+begin_src sh
$ git clone https://github.com/hectcastro/docker-riak.git
$ cd docker-riak
$ make build
#+end_src

* 一致性哈希

http://blog.csdn.net/cywosp/article/details/23397179/

一致性哈希算法在1997年由麻省理工学院提出的一种分布式哈希（DHT）实现算法，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简 单哈希算法带来的问题，使得分布式哈希（DHT）可以在P2P环境中真正得到应用。

 一致性hash算法提出了在动态变化的Cache环境中，判定哈希算法好坏的四个定义：

1、平衡性(Balance)：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。

2、单调性(Monotonicity)：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。 

3、分散性(Spread)：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。 

4、负载(Load)：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。
